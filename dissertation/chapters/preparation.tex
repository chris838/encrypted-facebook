%*****************************************
\chapter{Preparation}\label{ch:preparation}
%*****************************************

Here we discusses possible approaches to protecting privacy in social networks and how Encrypted Facebook relates to existing work. We briefly review Firefox extension development, the Facebook platform, broadcast encryption schemes and other security related concerns. We also look at the specific problems assosciated with encrypting images and possible solutions. Finally, we consider an appropriate testing strategy and software development methodology and derive a concrete set of requirements.

\section{Possible approaches}
\label{sec:approaches}

Protecting privacy involves tradeoffs between security, useability and scaleability. We outline possible approaches using examples from the literature and existing solutions.


\subsection{General}

It is possible to preserve pricacy by encrypting or otherwise hiding the link between a user and their online identity, as with NOYB. However, this approach suffers from problems of inference control and inherently degrades the quality of service provided by the social network. \footnote{See appendix XXX for a full discussion.} As such, we do not consider NOYB or this method further.

The alternative is to encyrpt the content shared a social networkd user, restricting access to only those who possess the appropriate key. This is the method emplyed by Encrypted Facebook and the other proposals introduced in section XXX.


\subsection{Outsourcing content}

As well as encryption, FaceCloak, flyByNight and uProtect.it also opt to migrate content from the Facebook platform to an external database. There are some advantages to this approach: since very little is being stored on Facebook itself measures can be taken to hide the fact that content is being encrypted at all (text steganography is otherwise difficult due to the low amount of redundancy) \cite{facecloak}. Better guarantees of availability can also be made in the case of account deletion.

Encrypted Facebook avoids outsourcing content due to scaleability concerns. Storing and delivering encrypted content requires at least the resources needed for storing and delivering the cleartext. Facebook is able to offer a free service by serving highly targetting advertising to its members based on the structure of the social graph \cite{fb-ads}. This revenue stream would be largely unavaible to any solution hosting a database of encrypted content, and paying for privacy is unlikely to be an option for the majority of users.


\subsection{Supporting multiple recipients}

Communication over social networks is typically one to many. There are several ways this can be achieved using encryption:

\begin {itemize}

    \item \textbf{Share a single symmetric key with you and your friends.} Requires secure out-of-band distribution of the key. Key revocation and providing fine grained control over recipient groups are problematic.
    
    \item \textbf{Keep your encryption key secret. Share your decryption key with your friends.} Subject to the same problems, however gives some protection against friends masquerading as you \cite{facecloak}. A variant of this is used for FaceCloak.
    
    \item \textbf{Keep your decryption key secret. Submit your encryption key to a third party who performs proxy re-encryption.} Used by flyByNight. Re-encryption allows content encrypted under one key-pair to be decrypted by another, without the third party ever being able to read the clear text \cite{flybynight}.
    
    \item \textbf{Authenticate with a trusted third party who posess all keys.} Confidentiality is only weakly assured: trust has simply been defered from Facebook to the third party and many of the scenarious raised in section \ref{sec:background} still apply. This does however greatly improve useability by removing the need for users to manage any keys whatsoever and is the basis of uProtect.it \cite{uprotect}.
    
    \item \textbf{Use a more complicated broadcast encryption scheme.} Many schemes exist with various tradeoffs, discussed in section XXX.
    
\end{itemize}

Relying on a third party for encryption or re-encryption is subject to the same scaleability issue as outsourcing content. In addition, any method which requires out-of-band transmission will likely suffer from useability isssues relating to manual key management \cite{johhny}.   

Encrypted Facebook uses a simple form of broadcast encryption, which is discussed in section XXX. No third party is required. Public key distribution is performed in-band; permitting semi-automated key management at the cost of vulnerability to middleperson attacks (discussed in section XXX). In addition, high resolution control over recipient groups and key revocation is possible.


\subsection{Supporting images}

Encrypted Facebook is currently the only solution that supports encrypted image content. Photo sharing is a primary concern for privacy concious users \cite{photos-priv} and one of the most common activities (section XXX). Possible approaches are covered in detail in section XXX.



\subsection{Intercepting Facebook interactions}

In order to encrypt content it must be intercepted before being submitted to Facebook. There are several possible stages at which this may occur (Figure \ref{fig:approaches}):

\begin{figure}[tbph]
\begin{center}
    \input{gfx/approaches_diag.tikz}
\caption{Possible deployment strategys for intercepting interaction with Facebook.}
\label{fig:approaches}
\end{center}
\end{figure}

\begin{enumerate}[(a)]
    
    \item A remotely hosted proxy server. Multiple users may access Facebook through the server.
    
    \item A proxy server running on localhost.
    
    \item Within the browser, outside the browser sandbox. Extensions and plugins operate here and have elevated priveledges over normal site code. Other examples include signed Java applets, ActiveX controls and to a lesser extent inline Flash and Silverlight applications. \footnote{Flash applications are restricted but can give basic filesystem access \url{http://blog.chromium.org/2010/12/rolling-out-sandbox-for-adobe-flash.html}.} FaceCloak takes this approach.
    
    \item Within the browser, entirely inside the browser sandbox - using only JavaScript and HTML. uProtect.it and flyByNight both take this approach.
    
    \item Outside the browser as a dedicated Facebook client application.
    
\end{enumerate}
   
(a) isn't possible without relying on a third party for hosting. The browser sandbox prevents local filesystem access, ruling out (d) if private keys are to be kept locally. Encrypted Facebook takes approach (c) since (b) and (e) are considerably more complex, at some cost to cross-platform compatability.

Manipulating the \ac{DOM} is well supported by browser extensions since the browser interface chrome is often built on existing web technologies. This allows Encrypted Facebook to integrate functionality into Facebook's own user interface, which, along with distributing public keys in-band, mitigates usebility issues concerning key management.

\section{Mozilla Firefox extension development}

Encrypted Facebook is developed for Mozilla Firefox. Firefox is the worlds most popular browser (as of January 2011) and has a large support base for extension development \cite{ffox}. Porting to other browser is discussed in section XXX.

Firefox extensions are written in JavaScript with partial support for Python and C/C++ \cite{ffox-lang}. Performing cryptography in JavaScript is possible but comes with severe performance difficulties \cite{flybynight}. Table \ref{tab:lang-speeds} compares approximate performance for each language (full details given in appendix xxx).

\begin{figure}[tbph]
\begin{center}
\begin{tabular}{+l ^l ^l}
    \rowstyle{\bfseries}%
    Language & Library & Time (ms) \\
    \midrule
    Python 2.6.6 & pycryptopp 0.5.17 & 1,220 ms \\ [1ex]
    C++ 98 & Botan 1.8.11 & 92 ms \\ [1ex]
    \parbox[t][][t]{20ex}{\raggedright JavaScript 1.6 (in Chrome 12.0.712)} & \parbox[t][][t]{20ex}{\raggedright JavaScrypt (last updated December 2005)} & 1,685,000 ms \\
\end{tabular}
\caption{Approximate time for 256-bit AES encryption of 1000 1.5 MiB random messages.}
\label{tab:lang-speeds}
\end{center}
\end{figure}

Since long delays would hamper usebility Encrypted Facebook uses C/C++ for computation intensive operations. Native code can executed from within Firefox in at least three ways:

\begin{itemize}

    \item Creating an XPCOM component. These are linked against a single Gecko \footnote{Gecko is the layout engine used by Firefox.} SDK version; supporting multiple versions is possible but non-trivial \cite{xpcom}.
    
    \item Loading native libraries with {\tt js-ctypes}. Introduced in Gecko 2.0 \cite{js-ctypes}. 

    \item Using {\tt nsiProcess} to invoke an external application. Capturing output can be difficult.
    
\end{itemize}

To maximise longevity Encrypted Facebook is designed to work on the latest version of the Firefox web browser, Firefox 4.0, which runs on Gecko 2.0. Since building an entire XCPOM component would be excessive and give little advantage by way of backwards compatibility, the newly introduced {\tt js-ctypes} module is used to load native code. 

Gecko 2.0 also provides better support for working with the local filesystem and manipulating images in the \ac{DOM}.


\section{The Facebook platform}


Encrypted Facebook supports encyrption for only the most popular types of object, listed in order of frequency of submission in Table \ref{tab:fb-activities}.

Encryption adds size overheads. Without relying on a third party server all overheads must be stored on Facebook itelf, in some form or another. Images and blog-style notes are obvious targets for storage utilisation due to their high capacity limits (see Table \ref{tab:fb-activities}). In particular, notes can contain over 120 KiB of information since each character represents one 16-bit unicode code point. Images are subject to lossy compression which is discussed in section XXX.

\begin{table}[tbph]
  \begin{center}
        \definecolor{lgray}{hsb}{0.1, 0, 0.9}
        \rowcolors{3}{white}{lgray}
        \begin{tabular}{+l ^l ^l ^l}
            \rowstyle{\bfseries}%
            Activity & Frequency  & Limitations & Notes \\
            \rowstyle{\bfseries}%
            & (per second) & & \\
            
            \midrule
            
            Comment         & 8,507    & 8,000 chars.   & \\ 
            Message         & 2,263    & 10,000 chars.  & \\
            Image           & 2,263    & $720 \times 720$ pixels   & \parbox[t][][t]{20ex}{\raggedright 3-channel 8-bit colour. JPEG compressed (see section XXX). } \\ [9ex]
            Friend request  & 1,643    &                & \parbox[t][][t]{20ex}{\raggedright Social graph structure.}  \\ [3ex]
            Status update   & 1,320    & 420 chars.     & \\
            Wall post       & 1,323    & 1,000 chars.   & \\
            Event invite    & 1,237    &                & \parbox[t][][t]{20ex}{\raggedright Social graph structure.}  \\[3ex]
            Photo tag       & 1,103    &                & \parbox[t][][t]{20ex}{\raggedright Social graph structure.}  \\[3ex]
            Link            & 833      &                & \parbox[t][][t]{20ex}{\raggedright }  \\
            Like            & unknown  &                & \parbox[t][][t]{20ex}{\raggedright Social graph structure.}  \\[3ex]
            Note            & unknown  & 65,536 chars.  & \parbox[t][][t]{20ex}{\raggedright Used for blog-style posts.} \\[3ex]
            
        \end{tabular}
        \caption{Facebook objects, their limitations and approximate frequency of creation \cite{fb-stats}}
        \label{tab:fb-activities}
    \end{center}
\end{table}


\subsection{Incremental deployment}

Need to allow for INCREMENTAL DEPLOYMENT. Needs to be an opt in scheme, don't want to divide SNS. Non-users must be able to co-exist with users. By this we basically mean low signal to noise ratio, link somewhere about this. This might require deleting objects

    
\subsection{Graph API}
 
Now we know what we need to interact with, how do we do it? Facebook Graph API (JavaScript API etc.). What we can do. What we can't that we need to (writing to profiles, problems with album ids etc.) Why I didn't use the JavaScript SDK - poorly documented, working with images is a pain. For the workarounds - iframes and forms - see the implementation.
    
\subsection{Connectedness}

    \begin{itemize}
        \item Facebook says average is 130. This paper \url{http://arxiv.org/PS_cache/cs/pdf/0611/0611137v1.pdf} says average is 170 and distrubtion drops sharply at 250. Cameron Marlow says we only speak to a core group of friends anyway.
        \item Theoretical limits - Dunbar number of 150, others suggest higher at ~300. So it perhaps won't increase with Facebook's expansion.
        \item Conclusion - 400 if we can make it work, but anything as low as 100 we could probably get away with.
    \end{itemize}

Conclusion: we must be able to send objects X,Y and Z, and will probably need to make use of A,B and C. Three different ways needed to connect to Facebook to achieve this. No JavaScript SDK; must not significantly increase signal to noise ratio; must suport at least 400 friends/recipients.

    
\section{Storing data in images}
    Images are the big thing. uProtect.it don't do images, FlyByNight talk about it as an extension.
    \begin{itemize}
	\item Description of Facebook/JPEG compression process (problem statement)
	\item Analysis of theoretical capacity
	\item Evaluation of naive implementations (MATLAB demonstrations). Obiously use gray codes to begin with.
            \begin{itemize}
		\item Completely naive (encode in RGB values)
		\item Slightly less so (encode in DST with bit masks)
                \item Possible better schemes: Haar and Scale.
                \item Optimal scheme? Dirty paper coding or similair? Its just too hard a problem but future work could be interesting.
             \end{itemize}
	\item Conclusion: possible approaches : Haar and Scale. Modularity and extensibility useful though since we don't know which is best and both are sub-optimal.
    \end{itemize}
    
\section{Encryption schemes}
    \begin{itemize}
        \item Threat model/analysis.
        \item Proxy re-encryption, like FlyByNite. Requires server side encryption so we leave it.
        \item Broadcast encryption.
        \begin{itemize}
            \item Naive implementation.
            \item More advanced schemes (and why I don't use them). Mainly due to no server side code, can't ask users to perform operations and expect a reply any time soon (or at all). We could reuse headers which would reduce a lot of size. In many ways this is a great idea, have a big linked list of notes containing links to headers, move frequently accessed entries to the front etc. However this means reusing message keys which is bad practice/NIST recommends against. Also, since we can only add and delete (not edit) notes (not through the API anyway, how fucking annoying) we might run into performance issues. 
            \item Underlying symmetric/asymmetric schemes. Maybe I could have improved the block size but ECC patents mean its not really found in open libraries.
        \end{itemize}
	
        \item Conclusion : simple broadcast encryption using AES and RSA underneath. However, modularity and extensibility would be useful because there are improvements. In particular ECC would give dramatically smaller overheads. 
    \end{itemize}
    
\section{Further security considerations}

\begin{itemize}
    \item Key management and size (NIST recommendations).
    \item Message key and IVs, don't reuse. Ensure good source of entrophy.
    \item Private key policy. Find a good reference, but basically we just mimic SSH and the like.
    \item Public key policy. Good idea to warn the user of the risks when they add public keys, check SSL is enabled etc.
\end{itemize}


\section{Testing plan}
    \begin{itemize}
	\item What kinds of testing will I use?
        \begin{itemize}
            \item Unit testing , anything else??
            \item Cognitive walkthrough - does this count as usability testing?
            \item Security testing, since potential for exploits and project is security based - important enough to warrant its own section.
        \end{itemize}
	\item How can I make these tests possible? Test bed or framework that needs to be in place?
        \begin{itemize}
            \item Need a method of simulating the Facebook JPEG compression process. Use libjpeg since it most closely matches the compression signature (table of compression signatures). Show coefficient table.
            \item Need a BER (bit error rate) calculator. Again coded as a C function.
            \item FireBug and FireUnit for unit testing and profiling JavaScript functions.
            \item gprof for profiling C/C++ functions.
        \end{itemize}
    \end{itemize}

\section{Security testing}

Loosely based on methodology here \url{http://mtc-m18.sid.inpe.br/col/sid.inpe.br/ePrint\%4080/2006/12.20.12.15/doc/v1.pdf}. Must compromise since full security audit beyond scope of project. Look only at text retrieval process and public key management. We ignore images, and general attacks (e.g. setting up a spoof Facebook site). We also ignore threats that would be present ANYWAY e.g. if you haven't got SSL on. As an extension expand threat model.

        \begin{itemize}
            \item Threat analysis. Threat = Agent x Mechanism x Asset.
            \begin{itemize}
                \item Facebook user creates a tag, which when decryption is attempted, causes denial of service (by locking up resources).
                \item Facebook user creates a tag which when decrypted injects script in to page, gains control of users browser, can exectute arbitraty scripts within the Facebook domain (XSS) gains access to Facebook cookies.
                \item Facebook user exploits UTF8 encoder/decoder to smuggle illegal characters past sanitization, gains control of users browser, can exectute arbitraty scripts within the Facebook domain (XSS) gains access to Facebook cookies.
                \item Facebook user injects text which is run by JavaScripts eval() function, can execute arbitrary JavaScript outside the sandbox. Very Very bad!
                \item Facebook user creates public key which, when parsed, creates a malicious file on the users local system.
            \end{itemize}
            \item Risk analysis. Risk = (Vulnrability x Threat x Impact) / Security Measures.
            \begin{itemize}
                \item Highest impact is running code outside the sandbox. True it maybe unlikely so long as we aren't stupid, but still. Basically we ban use of the eval function except for when we need it (retrieving JSON objects) then we replace it by a secureEval() which only allows valid Facebook object things.
                \item Access to Facebook cookies can impact our security guarantees (since they could then change the public key). Also vulnrability is high. Thus we take time to sanitize before we inject into the browser.
                \item Denial of service is low impact, but high vulnrability since the user need not do anyting to initate the decoding process other browsing to a site with a malicious post. So, test UTF8 decoder a lot, ensure that UTF8 decode, FEC decode, decrypt, all fail gracefully. Not image decode since out of scope, as mentioned above.
                \item Public keys we can limit to Base64 characters of a certain length. Done.
            \end{itemize}
            \item Test plan elabouration. From the above we want:
            \begin{itemize}
                \item Testing of secureEval. Overide or otherwise ban eval().
                \item Testing of text sanitiser.
                \item Testing of UTF8 de/codec. Complicated given the large range of i/o.
                \item Testing of public key downloader.
            \end{itemize}
        \end{itemize}
    
    
\section{Proffesional practice stuff}
    \begin{itemize}
	\item Software development methodology. Iterative prototyping. Work plan spells out which prototypes with what functionality should be completed when.
        \item Coding conventions, const correctedness etc.
	\item Version/source control. Git and project locker.
	\item Performance bounds. Of what???
    \end{itemize}
    
\section{Requirements analysis}
        
\begin{itemize}

    \item Encryption should be available on the most commonly used tasks (apart from those otherwise ruled out in section XXX). The user must therefore be able to broadcast-encrypt, submit, retrieve and decipher the following objects.

    
    \begin{itemize}
        \item Status updates
        \item Wall posts
        \item Comments
        \item Messages
        \item Images
    \end{itemize}
    
    Specifically, encryption should ensure confidentiality of data with at least 128 bits of security.
    
    \item All requirements should be met with recipient groups of size up to 400, which is a reasonable number - refer to discussion.
    
    \item Should be unobtrusive (refer to introduction) i.e. must not negatively affect browsing/Facebook experience of users. From this we derive the following:
    \begin{itemize}
        \item Should try not to introduce any security holes. Up to a point, given scope of project. We have already declared a threat model and testing strategy etc.
        \item Retrieval and submission times should be within acceptable limits. Define acceptable as \url{http://www.useit.com/papers/responsetime.html}.
        \item Must not confine users to one computer. Should be portable. Securely transporting private keys is up to the user however.
    \end{itemize}
    
    \item User activity should not negatively affect the activity of non-users (because of XXX refer to rest of preparation). We know there has to be some increase due to, for example, broadcast encryption overhead and status update's tiny length. Lets say maximum of twice number of objects generated compared to a normal user for the same activity.

    \item There are uncertainties and/or tradoffs associated with certain approaches to encryption and encoding data in images (and to a lesser extent error correction). It is also clear that in some cases the optimal approach is well beyond the scope of this project. Therefore, it is highly important that we adopt a modular structure that fascillitates switching between differing schemes and permits future extension. This need not extend to simultaneously supporting different schemes - this would introduce much redundant complexity.
    
    
\end{itemize}