%*****************************************
\chapter{Preparation}\label{ch:preparation}
%*****************************************

In this chapter we formulate the objectives presented in section \ref{sec:goals} into a set of design principles, drawing on existing work. We justify the use of broadcast encryption and define a suitable scheme. We describe possible deployment strategies and briefly review Firefox extension development and the Facebook platform. We also look at the specific problems assosciated with encrypting images and possible solutions. Finally, we discuss some additional security related concerns and draft a threat model, outline an appropriate testing strategy and software development methodology and derive a concrete set of requirements.


\FloatBarrier
\section{Design principles}

We describe the design principles of Encrypted Facebook; how they enforce the stated aims of privacy preservation, scaleability, usebility and incremental deployment and how they compare with existing approaches. Note that here use of the term third party excludes Facebook itself.


\FloatBarrier
\subsection{Encryption of shared content}

It is possible to preserve privacy by encrypting or otherwise concealing the link between a real life user and their online identity, as with NOYB \cite{noyb}. Arguably, however, privacy is only poorly preserved due to problems of inference control \cite{ross}. An example: many users will be easily identifiable simply from the photos they upload. Incremental deployment is also not possible since non-users will only ever see fictitious profiles \cite{facecloak}.

The alternative is to encrypt shared content itself in some way or another, restricting access to only those who possess the appropriate key even in the event of release.


\FloatBarrier
\subsection{Independency from third-party servers}

%In addition to encrypting content, flyByNight, FaceCloack and uProtect.it opt to migrate content from the Facebook platform to an external database. There are some advantages to this approach: since very little is being stored on Facebook itself measures can be taken to hide the fact that content is being encrypted at all, as with FaceCloak. \footnote{Steganography requires large amounts of redundancy to securely hide even a small amount of information \cite{facecloak}.} Better guarantees of availability can also be made in the case of account deletion.

In addition to encrypting content, flyByNight, FaceCloack and uProtect.it all opt to migrate content from the Facebook platform to an external third party database.

With Encrypted Facebook we avoid outsourcing content due to scaleability concerns. Storing and delivering encrypted content requires at least the resources needed for storing and delivering the cleartext.  Facebook's monthly bandwidth overheads alone are in excess of two million dollars \cite{fb-costs}. They are able to offer a free service by serving highly targetting advertising to members based on the structure of the social graph \cite{fb-ads}. This revenue stream would be largely unavaible to any solution hosting a database of encrypted content. A subscription based service would also be unlikely to scale, since the majority of Facebook users would be reluctant to pay \cite{fb-pay}.

%Third-party servers can also be employed for computation. uProtect.it performs all encryption and decryption server side negating the need for the user to perform any kind of kind of key management. Proxy re-encryption, used by flyByNight to permit multiple recipients \cite{flybynight}, also relies on access to server side computation, as do some of the more advanced broadcast encryption schemes (see section XXX).

Third-party servers can also be employed for performing encryption and/or decryption, as with uProtect.it and flyByNight. We avoid taking this approach, again since the resources required by the server would scale linearly in proportion to the amount of content exchanged.

Another use of third-party servers is to store and distribute cryptographic keys, perhaps as part of a public key infrastructure. Arguably issues of scale here are not so severe. In any case we do not rely on such a service due to conflicts with other design principles, or in some cases due to a limited percieved benefit given the additional complexity of impementation.


\FloatBarrier
\subsection{Secret key security}

Any encryption scheme will require some form of key whose secrecy is required.

It is possible to use a trusted third-party to store and distribute secret keys, in a so-called key escrow arrangement. Key management can even be taken out of the users hands entirely, improving usebility. This is the basis of uProtect.it \cite{uprotect}. However, confidentiality is only weakly assured: trust has simply been defered from Facebook to the third-party and many of the scenarious raised in section \ref{sec:background} still apply.

Another possibility is using secret keys derived from a password. flyByNight, for example, allows users to download a password-protected private key from their server. We could also store password protected keys in-band (i.e. on Facebook itself) or generate a key simply by hashing a password. Again, relying on the user to memorise a password rather than manage secret keys improves usebility. Unfortunately the entrophy of user chosen passwords is far less than that of randomly generated keys \cite{password}.

With Encrypted Facebook we ensure keys are only ever generated and stored on the user's device(s), trading usebility for better privacy protection.


\FloatBarrier
\subsection{Minimal use of OOB channels}

Secure \ac{OOB} channels (such as encrypted email or face-to-face exchange) can be used to transmit update messages, keys or other information as part of an encryption scheme (see section XXX). Since these channels are, by definition, external to the Facebook platform it can be hard to automate such exchanges and much is still required from the user. FaceCloak, for example, requires users to transmit messages over secure email when adding friends. The process is partly automated, however the user must set up an email client themselves and ensure that the email is sent securely (by using PGP, for example).

Encrypted Facebook is designed to limit the use of \ac{OOB} transmission due to usebility concerns regarding manual key managament. The exception is when installing a secret key across more than one device - since transporting a secret key by any other method would comprimise the principle of secret key security.


%\subsection{Remainder of communications in-band}

%Any system which uses public key cryptography will require some way of distributing public keys. Although they are 'public', a so-called middleperson attack can occur if keys are intercepted \cite{ross}.

%Since public keys are likely to be transmitted often (depending on the protocol, every time a friend is added or even every time content is shared) doing so \ac{OOB}, although secure, will impact usebility - again since \ac{OOB} transmition is hard to automate.

%We can instead store and distribute public keys via a trusted third-party. flyByNight takes this approach.  If the content server and the key server are distinct (for example, if Facebook itself is used to store content) both would have to be comprimised to perform so called middleperson attacks. Also web of trust.

%For the sake of simplicity Encrypted Facebook transmits public keys in-band on Facebook itself, since immunity from middleperson attacks is not considered a design goal. Such attacks are discussed fully in section XXX. \footnote{The option of verifying public keys \ac{OOB} to prevent middleperson attack is left open to the expert user but is not a design feature.}


\FloatBarrier
\section{Broadcast encryption}

Communication over social networks is typically one-to-many whereas cryptography traditionally considers a sender and a single recipient. We look at existing solutions to this problem and outline the broadcast encryption scheme adopted by Encrypted Facebook and a justification for its use.


\FloatBarrier
\subsection{Existing solutions}

Existing proposals tackle this problem in the following ways:

\begin{itemize}

    \item If content is both hosted and encrypted/decrypted remotely, as with uProtect.it, one-to-many support is trivial. The user simply authenticates with the server and is sent the cleartext.
    
    \item If a third-party can be used for computation we can use a technique called proxy re-encryption as with \cite{flybynight}. Here the server changes the key under which the content may be decrypted on demand, without ever being able to read the cleartext itself \cite{proxy}.
    
    \item Distributing keys over \ac{OOB} channels can permit one-to-many communication. A FaceCloak user, for example, shares a single decryption key \ac{OOB} among friends.

\end{itemize}

None of these approaches are compatible with Encrypted Facebook's design principles. Instead we use a form of broadcast encryption.


\FloatBarrier
\subsection{Proposed scheme}

Appendix XXX gives a full introduction to broadcast encryption schemes. In general they can be characterised by the size of each users private and public key and the amount of transmission overhead that must be sent with each message, given the number of recipients. The scheme presented here has a large transmission overhead, however unlike many more complex schemes it doesn't require the use of key-update messages. Transmiting key-updates \ac{OOB} or though a third party would violate our design principles. Transmitting them in-band would be possible, but since Facebook is a "best effort" service synchronisation and lost updates would likely be a problem. Further discussion of more advanced schemes is included in appendix XXX.

Let $U$ be the set of users with Encrypted Facebook installed and $R \subseteq U$ be a set of intended recipients. Our broadcast encryption scheme is defined as follows:


\begin{defn}
    
    Given a suitable asymmetric encryption scheme $P$ and a suitable symmetric scheme $Q$, we define our broadcast encryption scheme as the triple of algorithms {\sc (Setup, Broadcast, Decrypt)} such that:
    
    \begin{itemize}
    
    \item The setup algorithm {\sc (Setup)} takes a user $u \in U$ and constructs that receiver's private kev $priv_u$ and public key $pub_u$ using scheme $P$.
    
    \item The broadcast algorithm {\sc (Broadcast)} takes the list of priveledged users $R$ and a message $m$, generates a session key $k$ using scheme $Q$ and broadcasts a message $b = (b_1,b_2)$ where:
    
    \begin{itemize}
        \item $b_1$ is the list of pairs $(u,k_u)$ such that $u \in R$, where $k_u$ is the session key encrypted under $pub_u$.
        \item $b_2$ is $m$ encrypted under a session key $k$.
    \end{itemize}
    
    
    \item A user $u \in U$ runs the decryption algorithm {\sc Decrypt($b, u, priv_u$)} that will:
    
        \begin{itemize}
            \item If $(u,k_u) \in b_2$, extract the session key $k$ from $k_u$ using $priv_u$. $m$ is obtained by decrypting $b_2$ using $k$
        
            \item {\sc Decrypt} fails, if $(u,k_u) \notin b_2$ or if, equivalently, $u \notin R$.
        
        \end{itemize}

    \end{itemize}
    

\end{defn}    


\FloatBarrier
\section{Intercepting Facebook interactions}

In order to encrypt content it must be intercepted before being submitted to Facebook. We describe the possible stages at which this may occur (Figure \ref{fig:approaches}):

\begin{figure}[tb]
\begin{center}
    \input{gfx/approaches_diag.tikz}
\caption{Possible deployment strategies for intercepting interaction with Facebook.}
\label{fig:approaches}
\end{center}
\end{figure}


\begin{enumerate}
\renewcommand{\labelenumi}{\alph{enumi})}
    
    \item On a remotely hosted proxy server. Easier multi-OS and multi-browser support.
    
    \item On a proxy server running on localhost. Easier multi-browser support.
    
    \item Within the browser, outside the browser sandbox. Extensions and plugins exist here and have elevated priveledges over normal site code. Other examples include signed Java applets, ActiveX controls and to a lesser extent inline Flash and Silverlight applications. \footnote{Flash applications, for example, are restricted but can provide basic filesystem access \cite{flash-sbox}.} FaceCloak takes this approach.
    
    \item Within the browser, entirely inside the browser sandbox - using only JavaScript and HTML. uProtect.it and flyByNight both take this approach.
    
    \item Outside the browser as part of a bespoke Facebook client application.
    
\end{enumerate}
   
(a) conflicts with the design goal of no server-side computation. The browser sandbox prevents local filesystem access, ruling out (d) if private keys are to be kept securely. We take approach (c) since (b) and (e) are considerably more complex, at some cost to cross-platform compatability.



\FloatBarrier
\section{Mozilla Firefox extension development}

Encrypted Facebook is developed as an extension for Mozilla Firefox, the worlds most popular browser (as of January 2011). Manipulating the \ac{DOM} is well supported by browser extensions since the browser interface chrome is often built on existing web technologies. This allows Encrypted Facebook to integrate functionality into Facebook's own user interface which mitigates usebility issues concerning key management. Porting to other browsers is discussed in section XXX.

Firefox extensions are written in JavaScript with partial support for binding library code written in Python or C/C++ \cite{ffox-lang}. Performing cryptography in JavaScript is possible but comes with severe performance difficulties \cite{flybynight}. Table \ref{tab:lang-speeds} compares approximate performance for each language (full details given in appendix xxx).


\begin{figure}[tb]
\begin{center}
\begin{tabular}{+l ^l ^l}
    \rowstyle{\bfseries}%
    Language & Library & Time (ms) \\
    \midrule
    Python 2.6.6 & pycryptopp 0.5.17 & 1,220 ms \\ [1ex]
    C++ 98 & Botan 1.8.11 & 92 ms \\ [1ex]
    \parbox[t][][t]{20ex}{\raggedright JavaScript 1.6 (in Chrome 12.0.712)} & \parbox[t][][t]{20ex}{\raggedright JavaScrypt (last updated December 2005)} & 1,685,000 ms \\
\end{tabular}
\caption{Approximate time for 256-bit AES encryption of 1000 1.5 MiB random messages.}
\label{tab:lang-speeds}
\end{center}
\end{figure}

Since long delays would hamper usebility Encrypted Facebook uses C/C++ for computation intensive operations. Native code can be executed from within Firefox in at least three ways:

\begin{itemize}

    \item Creating an XPCOM component. These are linked against a single Gecko \footnote{Gecko is the layout engine used by Firefox.} version; supporting multiple versions is possible but non-trivial \cite{xpcom}.
    
    \item Loading native libraries with {\tt js-ctypes}. Introduced in Gecko 2.0 \cite{js-ctypes}. 

    \item Using {\tt nsiProcess} to invoke an external stand-alone application. Capturing output can be difficult.
    
\end{itemize}

Since building an entire XCPOM component would be excessive and give little advantage by way of multi-version compatibility, the newly introduced {\tt js-ctypes} module is used to load native code. This restricts use of Encrypted Facebook to Firefox version 4.0 and above. Gecko 2.0 does also provides slightly better support for working with the local filesystem and manipulating images in the \ac{DOM}.


\FloatBarrier
\section{The Facebook platform}

Facebook represents the social graph as objects and connections between them. Objects include users, photos, messages and events. All objects are assigned a single unique Facebook ID, and all objects (except users themselves) are assosciated with the ID of their owner. The owners privacy settings (global and per object) will determine who may access an object. Objects will also have connections to other users and other objects. For example, users can create discussion threads by commenting on objects or tag other users as being present in a photograph.

There are many ways users can interact with Facebook. We will make the generalisation that interaction amounts to creating and retrieving content - i.e. objects in the social graph. Our goal then is to encrypt and decrypt the properties of certain objects - e.g. the body of a message object. We do not attempt to encrypt or otherwise conceal connections between objects, this is an non-goal as stated in section XXX.

We describe the most popular forms of content submitted and discuss issues relating to the connectedness of user nodes and signal-to-noise ratio in the network. We then briefly look at methods of interfacing with the Facebook platform.

\FloatBarrier
\subsection{Content types}

Encrypting all possible types of content would be prohibitively complex. We therefore aim to encrypt only those most frequenclty used. From Table \ref{tab:fb-activities} we can clearly see that these are Comments, Messages, Images and Posts. 

Our broadcast encryption scheme described in section XXX adds size overheads to any content that will be encrypted. Without relying on a third-party server all overheads must be stored on Facebook itelf, in some form or another. Images and blog-style notes are obvious targets for storage utilisation due to their high capacity limits (see Table \ref{tab:fb-activities}). In particular, notes can contain over 120 KiB of information since each character represents one 16-bit unicode code point. Images are subject to lossy compression which is discussed in section XXX.

\begin{table}[tb]
  \begin{center}
        \definecolor{lgray}{hsb}{0.1, 0, 0.9}
        \rowcolors{3}{white}{lgray}
        \begin{tabular}{+l ^l ^l ^l}
            \rowstyle{\bfseries}%
            Activity & Frequency  & Limitations & Notes \\
            \rowstyle{\bfseries}%
            & (per second) & & \\
            
            \midrule
            
            Comment         & 8,507    & 8,000 chars.   & \\ 
            Message         & 2,263    & 10,000 chars.  & \\
            Image           & 2,263    & $720 \times 720$ pixels   & \parbox[t][][t]{20ex}{\raggedright 3-channel 8-bit colour. JPEG compressed (see section XXX). } \\ [9ex]
            Friend request  & 1,643    &                & \parbox[t][][t]{20ex}{\raggedright Social graph structure.}  \\ [3ex]
            Status update   & 1,320    & 420 chars.     & \\
            Wall post       & 1,323    & 1,000 chars.   & \\
            Event invite    & 1,237    &                & \parbox[t][][t]{20ex}{\raggedright Social graph structure.}  \\[3ex]
            Photo tag       & 1,103    &                & \parbox[t][][t]{20ex}{\raggedright Social graph structure.}  \\[3ex]
            Link            & 833      &                & \parbox[t][][t]{20ex}{\raggedright }  \\
            Like            & unknown  &                & \parbox[t][][t]{20ex}{\raggedright Social graph structure.}  \\[3ex]
            Note            & unknown  & 65,536 chars.  & \parbox[t][][t]{20ex}{\raggedright Used for blog-style posts.} \\[3ex]
        \end{tabular}
        \caption{Facebook objects, their limitations and approximate frequency of creation \cite{fb-stats}}
        \label{tab:fb-activities}
    \end{center}
\end{table}

Each user's profile has an "About Me" field with a character limit of XXX. With no other obvious capacitous attribute that can be easily queried from user ID, this is an obvious place to store a user's public key.

    
\FloatBarrier
\subsection{Connectedness}

Since Encrypted Facebook's broadcast encryption scheme has a transmission overhead proportional to the number of intended recipients, care must be taken to ensure the system works with large enough recipient groups. The number of recipients is bounded by the number of friends a user or equivalently by the degree of the user's node in the social graph. 

Empirical estimates for the average number of Facebook friends range from 130 to 170, with some evidence suggesting the distribution drops of sharply at around 250 \cite{fb-factsheet} \cite{fb-connectedness}. Marlow et al suggest that, regardless of the number of friends, communication is only ever between a small subset \cite{burke2010social}.

The Dunbar number is a theoretical cognitive limit to the number of people a user can maintain relationships with and has been applied to social networks as well as face-to-face interactions. Exact estimates range from around 150 to 300 \cite{xxx} \cite{xxx}, suggesting that the average degree of nodes within a social graph like Facebook's is unlikely to increase dramatically as Facebook expands further.

We this in mind we make it a requirement that the extension operates with recipient group sizes of up to 400.


\FloatBarrier
\subsection{Signal-to-noise ratio}

Activity within the social graph causes notifications to be posted to feeds. Each user has a 'news feed' of nearby graph activity which is presented to them on logging in, and also a 'wall feed' of their own activity. Interaction with Facebook revolves around these feeds and it is vital that the signal-to-noise ratio is kept high. This is the proportion of useful content to non-useful content: typically spam, but in our case this could be transmission overheads as part of the broadcast encryption scheme, or even the encrypted content itself since a user without Encrypted Facebook installed will be unable to see the cleartext.

In order to permit incremental deployment any system must ensure that its users can coexist with non-users. We therefore make it a requirment to limit the extensions impact on the signal-to-noise ratio of feeds.


\FloatBarrier
\subsection{Graph API}

Facebook does provide a JavaScript SDK for interfacing with the Facebook platform, however it is poorly documented and doesn't allow uploading images - since most JavaScript applications are designed to run inside the browser sandbox without local filesystem access. Instead we use the Facebook Graph API directly.

Objects can be read simply by making GET requests to \url{https://graph.facebook.com/ID} and parsing the return result as a JSON object. For none public objects we will also require an access token. Facebook uses the OAuth 2.0 protocol. An access token can be obtained by handling the page redirect \footnote{To ensure authentication can only occur in client side code the access token is passed in a URI fragment.} after the following GET request:

\FloatBarrier
    \begin{lstlisting}[label=code:auth,caption=Authentication GET request,float=h]
        https://www.facebook.com/dialog/oauth?
            client_id=APP_ID&
            redirect_uri=REDIRECT_URL&
            scope=SCOPE_VAR1,SCOPE_VAR2,SCOPE_VAR3&
            response_type=token
    \end{lstlisting}
\FloatBarrier

    
Content can also be published in a similair way. An example request might look like:

\FloatBarrier
    \begin{lstlisting}[label=code:pub,caption=Publishing POST request,float=h]
        https://graph.facebook.com/ID/feed?
            access_token=ACCESS_TOKEN&
            message=MESSAGE
    \end{lstlisting}
\FloatBarrier    
    

There are several caveats:

\begin{itemize}

    \item When publishing images, although the operation is supported, getting a correct handle to the image is difficult due to JavaScript's poor support for working with local files. The workaround requires creating an invisible form on the current page with a file input element and extracting the file handle from there.

    \item Images have to be published to an album. Facebook currenly uses two types of album ID, one which appears within web pages and one which can be used for publishing through the Graph API. An additional API query is required before uploading to tranlate from one format to the other.
    
    \item It certain cases, though publishing through the Graph API is possible, it is more conveniant to programatically manipulate form controls. An example is when submitting a comment and triggering the click handler for the submit button.
    
    \item Modifying the "About Me" section of a users profile is unsupported entirely. The workaround requires creating an invisible iframe on the current page and manipulating a form on the Facebook site within.

\end{itemize}

    
\FloatBarrier
\section{Storing data in images}

As well as being one of the most frequently used types of content, images have been highlighted as a prime privacy concern on social networks \cite{fb-images}. None of the existing work supports image encryption, though flyByNight mentions is as a possible extension.

The main problem is that, regardless of the input format, Facebook encodes all uploaded images using lossy JPEG. \footnote{Even if a file is already in the output format the compression process is repeated and information is lost.} This means we require some form of JPEG-immune coding to store the binary output of encryption in an image, such that even after undergoing compression we can exactly recover the original bytes.

We being by describing Facebook's JPEG compression process and evaluating naive attempts at encoding data in images, before proposing two more advanced approaches.

\FloatBarrier
\subsection{JPEG compression process}

Information is lost at several stages:

\begin{enumerate}

    \item Colour images are subject to a lossy colour space transform from RGB to YCrCb.
    \item The chrominance components Cr and Cb are subsampled at a rate half that of the lumuninance channel.
    \item The discrete cosine transform is applied to each 8x8 block using floating point arithmetic.
    \item DCT coefficients are quantised according to values in a quantisation matrix.
    
\end{enumerate}

Note that chrominance subsampling means that colour images only provide a 50\% increase in capacity over a grayscale image of the same resolution. For simplicity we will only consider grayscale images. This leaves quantisation as the principle step at which information loss occurs.

Table \ref{tab:quants} displays the quantisation matrix used for a grayscale JPEG image downloaded from Facebook. Using this and several other compression parameters our best guess is that Facebook is using the libjpeg library for compression, with a quality factor setting of 85. \footnote{Based on the output of the JPEG Snoop application for Windows.}

\begin{table}[tb]
\begin{center}
    %\definecolor{lgray}{hsb}{0.1, 0, 0.9}
    %\rowcolors{3}{white}{lgray}
    \begin{tabular}{|+c |^c |^c |^c |^c |^c |^c |^c |}
    \hline
    \multicolumn{8}{|c|}{\bf Quantisation Matrix} \\ \hline
    \hline
    5 & 3 & 3 & 5 & 7 & 12 & 15 & 18 \\ \hline
    4 & 4 & 4 & 6 & 8 & 17 & 18 & 17 \\ \hline
    4 & 4 & 5 & 7 & 12 & 17 & 21 & 17 \\ \hline
    4 & 5 & 7 & 9 & 15 & 26 & 24 & 19 \\ \hline
    5 & 7 & 11 & 17 & 20 & 33 & 31 & 23 \\ \hline
    7 & 11 & 17 & 19 & 24 & 31 & 34 & 28 \\ \hline
    15 & 19 & 23 & 26 & 31 & 36 & 36 & 30 \\ \hline
    22 & 28 & 29 & 29 & 34 & 30 & 31 & 30 \\ \hline
\end{tabular}
\end{center}

\caption{Quantisation matrix used by Facebook for luminance channel.}
\label{tab:quants}

\end{table}


\FloatBarrier
\subsection{Naive data insertion}

We encode data in an image and compress/decompress at quality factor 85, using libjpeg. We then examine the Hamming distance between the output and the original data and compute the bit error rate.

For each DCT coefficient with corresponding quantisation coefficient $c$ we know that:

\begin{itemize}

    \item $ \lceil \log_2 n \rceil $ low order bits will be lost during quantisation.
    
    \item Setting higher order bits is undesirable due to clipping. Large magnitudes are more likely to produce values which fall outside the 0-255 interval when performing the inverse DCT. 

\end{itemize}

Figure XXX graphs the error rates for naive insertion in to RGB values and insertion into DCT coefficients using a bitmask. Figure XXX also shows the per image capacity calculated by modelling the compression process as a binary symmetric channel (details for this are given in Evaluation section XXX).


\begin{figure}[tbph]
  \begin{center}
\begin{tikzpicture}
    \begin{axis}[grid=major,xlabel=JPEG Quality Factor,ylabel=BER (\%), xmin=80, xmax=90,
    height=9cm,width=11cm,legend style={legend pos=outer north east}]
    
    \addplot
        table[x=QF,y=rgb] {gfx/error_rate0.data};
    
        
    \legend{RGB,DCT}
    
    \end{axis}
\end{tikzpicture}
    \caption{Bit error rate for varying quality factors.}
    \label{graph:ber0}
  \end{center}
\end{figure}

\begin{figure}[tbph]
  \begin{center}
\begin{tikzpicture}
    \begin{axis}[grid=major,xlabel=JPEG Quality Factor,ylabel=Capacity (KiB/image), xmin=80, xmax=90,
    height=9cm,width=11cm,legend style={legend pos=outer north east}]
    
    \addplot
        table[x=QF,y=Sc3] {gfx/encoding_time.data};
    
    \addplot
        table[x=QF,y=Sc4] {gfx/encoding_time.data};
        
    \legend{RGB,DCT}
    
    \end{axis}
\end{tikzpicture}
    \caption{Per-image channel capacity (measured in KiB/image) for varying quality factors.}
    \label{graph:capacity0}
  \end{center}
\end{figure}


\FloatBarrier
\subsection{Advanced data insertion}

We map binary data on to appropraite length gray codes to ensure that only single bit errors occur from erroneously an adjacent codeword.

\begin{itemize}

    \item JPEG DCT compression selectively quantises high frequency components since these are less perceptually salient. Wavelet transforms allow us to embed data in the low frequency sub-band of the carrier signal and can be performed reversibly (i.e. losslessly) by using an integer lifting scheme. Xu et al demonstrate that \cite{haar} data encoded in the low-frequency approximation coefficients can survive JPEG decompression when combined with an error correction scheme.
    
    \item What will from now on be refered to as a n-bit scaling method. We map the n-bit input space on to the 8-bit pixel space by scaling and shifting the input such that 0 corresponds to 0, and $2^n$ corresponds to 256. The inverse process amounts to outputting which interval the data lies in.

\end{itemize}

Clearly both these schemes are sub-optimal and their exact properties (compression time and error rates) are unknown. We make it a requirement that the project should take a modular approach to conduit image implementations to ensure that a) both of the proposed schemes can be implemented simulatnaously and their performances compared and b) to aid future development of a more optimal solution.



\FloatBarrier 
\section{Further security considerations}


\FloatBarrier
\subsection{Threat model}

We describe an attack centric threat model based on the methodoloy of \cite{XXX}



\FloatBarrier
\subsection{Underlying encryption schemes}

We use AES and RSA as both schemes are approved by NIST standards \cite{nist} and widely available via the Botan cryptography library. Ideally however, we would have liked to use a scheme based on eliptic curve cryptography since public key sizes are much smaller for the same amount of security than finite field or integer factorisation. This is important since the block size of the cipher depends on the public key, and this in turn determines the size of the session key once it has been encrypted. In our case, for example, a 256-bit AES session key requires 2048-bits of transmission overhead per recipient. Unfortunately ECC is less common due to patent concernse \cite{XXX}. Again, we make it a requirement that the project be modular enough to allow later insertion of more optimal scheme.


\FloatBarrier
\subsection{Key management}        
	
    
\begin{itemize}


    \item Key management and size (NIST recommendations).
    \item Message key and IVs, don't reuse. Ensure good source of entrophy.
    \item Private key policy. Find a good reference, but basically we just mimic SSH and the like.
    \item Public key policy. Good idea to warn the user of the risks when they add public keys, check SSL is enabled etc.
\end{itemize}


\FloatBarrier
\section{Testing plan}
    \begin{itemize}
	\item What kinds of testing will I use?
        \begin{itemize}
            \item Unit testing , anything else??
            \item Cognitive walkthrough - does this count as usability testing?
            \item Security testing, since potential for exploits and project is security based - important enough to warrant its own section.
        \end{itemize}
	\item How can I make these tests possible? Test bed or framework that needs to be in place?
        \begin{itemize}
            \item Need a method of simulating the Facebook JPEG compression process. Use libjpeg since it most closely matches the compression signature (table of compression signatures). Show coefficient table.
            \item Need a BER (bit error rate) calculator. Again coded as a C function.
            \item FireBug and FireUnit for unit testing and profiling JavaScript functions.
            \item gprof for profiling C/C++ functions.
        \end{itemize}
    \end{itemize}


\FloatBarrier
\section{Security testing}

Loosely based on methodology here \url{http://mtc-m18.sid.inpe.br/col/sid.inpe.br/ePrint\%4080/2006/12.20.12.15/doc/v1.pdf}. Must compromise since full security audit beyond scope of project. Look only at text retrieval process and public key management. We ignore images, and general attacks (e.g. setting up a spoof Facebook site). We also ignore threats that would be present ANYWAY e.g. if you haven't got SSL on. As an extension expand threat model.

        \begin{itemize}
            \item Threat analysis. Threat = Agent x Mechanism x Asset.
            \begin{itemize}
                \item Facebook user creates a tag, which when decryption is attempted, causes denial of service (by locking up resources).
                \item Facebook user creates a tag which when decrypted injects script in to page, gains control of users browser, can exectute arbitraty scripts within the Facebook domain (XSS) gains access to Facebook cookies.
                \item Facebook user exploits UTF8 encoder/decoder to smuggle illegal characters past sanitization, gains control of users browser, can exectute arbitraty scripts within the Facebook domain (XSS) gains access to Facebook cookies.
                \item Facebook user injects text which is run by JavaScripts eval() function, can execute arbitrary JavaScript outside the sandbox. Very Very bad!
                \item Facebook user creates public key which, when parsed, creates a malicious file on the users local system.
            \end{itemize}
            \item Risk analysis. Risk = (Vulnrability x Threat x Impact) / Security Measures.
            \begin{itemize}
                \item Highest impact is running code outside the sandbox. True it maybe unlikely so long as we aren't stupid, but still. Basically we ban use of the eval function except for when we need it (retrieving JSON objects) then we replace it by a secureEval() which only allows valid Facebook object things.
                \item Access to Facebook cookies can impact our security guarantees (since they could then change the public key). Also vulnrability is high. Thus we take time to sanitize before we inject into the browser.
                \item Denial of service is low impact, but high vulnrability since the user need not do anyting to initate the decoding process other browsing to a site with a malicious post. So, test UTF8 decoder a lot, ensure that UTF8 decode, FEC decode, decrypt, all fail gracefully. Not image decode since out of scope, as mentioned above.
                \item Public keys we can limit to Base64 characters of a certain length. Done.
            \end{itemize}
            \item Test plan elabouration. From the above we want:
            \begin{itemize}
                \item Testing of secureEval. Overide or otherwise ban eval().
                \item Testing of text sanitiser.
                \item Testing of UTF8 de/codec. Complicated given the large range of i/o.
                \item Testing of public key downloader.
            \end{itemize}
        \end{itemize}
    
   
\FloatBarrier 
\section{Proffesional practice stuff}
    \begin{itemize}
	\item Software development methodology. Iterative prototyping. Work plan spells out which prototypes with what functionality should be completed when.
        \item Coding conventions, const correctedness etc.
	\item Version/source control. Git and project locker.
	\item Performance bounds. Of what???
    \end{itemize}
    
\FloatBarrier
\section{Requirements analysis}
        
\begin{itemize}

    \item Encryption should be available on the most commonly used tasks (apart from those otherwise ruled out in section XXX). The user must therefore be able to broadcast-encrypt, submit, retrieve and decipher the following objects.

    
    \begin{itemize}
        \item Status updates
        \item Wall posts
        \item Comments
        \item Messages
        \item Images
    \end{itemize}
    
    Specifically, encryption should ensure confidentiality of data with at least 128 bits of security.
    
    \item All requirements should be met with recipient groups of size up to 400, which is a reasonable number - refer to discussion.
    
    \item Should be unobtrusive (refer to introduction) i.e. must not negatively affect browsing/Facebook experience of users. From this we derive the following:
    \begin{itemize}
        \item Should try not to introduce any security holes. Up to a point, given scope of project. We have already declared a threat model and testing strategy etc.
        \item Retrieval and submission times should be within acceptable limits. Define acceptable as \url{http://www.useit.com/papers/responsetime.html}.
        \item Must not confine users to one computer. Should be portable. Securely transporting private keys is up to the user however.
    \end{itemize}
    
    \item User activity should not negatively affect the activity of non-users (because of XXX refer to rest of preparation). We know there has to be some increase due to, for example, broadcast encryption overhead and status update's tiny length. Lets say maximum of twice number of objects generated compared to a normal user for the same activity.

    \item There are uncertainties and/or tradoffs associated with certain approaches to encryption and encoding data in images (and to a lesser extent error correction). It is also clear that in some cases the optimal approach is well beyond the scope of this project. Therefore, it is highly important that we adopt a modular structure that fascillitates switching between differing schemes and permits future extension. This need not extend to simultaneously supporting different schemes - this would introduce much redundant complexity.
    
    
\end{itemize}