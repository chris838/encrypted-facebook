%*****************************************
\chapter{Conclusion}\label{ch:conclusion}
%*****************************************

\section{Evaluation of Requirements}

It works, and works for groups of 400 - covered by cognitive walkthrough. Also group size of 400 made possible by image method.

Should be unobtrusive - security holes we dealt with according to threat model, best compromise we can come up with. Timing breakdown says not waiting around. Cognitive walkthrogh demonstrates portability.

Incremental deployment - refer to impementation, we nailed this trivially.

Extensible and configurable library components - refer to implementation, can actually does this at run time, abstract factory groups families of components. Also refer to image method evaluation - clearly had to swtich between them to run these test.

\section{Retrospective}

What I would have done differently?

No point in implementing Haar since it has poor poor capacity.

Pushed more stuff in to the C library, then most of the JavaScript for modfying the Facebook UI could be reused for a chrome extension, firefox extension, other browsers etc.

\section{Future work}

Would be great if we could use ECC encryption because overhead would be cut by a big factor, though patent issues etc. mean bad.

Would be great to find an optimal solution to the image problem. Practically it doesnt make much difference but from a theoretical perspective its interesting - could easily turn into a thesis.

\section{Potential deployment}

Obviously would need to expand threat model and deal with security holes.

Main problem is Linux-only at the moment. Wouldn't take too much trouble to compile on Windows though.

The idea about seperating headers from content is cool. Would be nice to experiment regarding the performance hit, but essentially we could have sliding parameter which indicated security vs storage overhead tradeoff.


