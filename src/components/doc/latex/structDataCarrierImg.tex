\hypertarget{structDataCarrierImg}{
\section{DataCarrierImg Struct Reference}
\label{structDataCarrierImg}\index{DataCarrierImg@{DataCarrierImg}}
}


Class representing a \hyperlink{structcimg__library_1_1CImg}{CImg$<$char$>$} with support for implanting and extracting data.  


Inheritance diagram for DataCarrierImg:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{structDataCarrierImg}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{structDataCarrierImg_ad115dc610f3f7528767d4aa45fa35b66}{format\_\-for\_\-implantation} ()
\begin{DoxyCompactList}\small\item\em Format the image in preparation for implantation. \item\end{DoxyCompactList}\item 
void \hyperlink{structDataCarrierImg_a5fdd25e16c1d5b86b68acac5a24ecae4}{implant\_\-data} (std::vector$<$ char $>$ \&data)
\begin{DoxyCompactList}\small\item\em Implant a specified vector$<$char$>$ into the image. \item\end{DoxyCompactList}\item 
void \hyperlink{structDataCarrierImg_a7769dc5e2644c5c1d13cbeb7235c5304}{extract\_\-data} (std::vector$<$ char $>$ \&data)
\begin{DoxyCompactList}\small\item\em Attempt to allocate and return a new vector$<$char$>$ containing the extracted data. \item\end{DoxyCompactList}\item 
\hypertarget{structDataCarrierImg_ade2d300f665591ba4b5870dcb4afe251}{
\hyperlink{structDataCarrierImg_ade2d300f665591ba4b5870dcb4afe251}{DataCarrierImg} ()}
\label{structDataCarrierImg_ade2d300f665591ba4b5870dcb4afe251}

\begin{DoxyCompactList}\small\item\em Default constructor. \item\end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Class representing a \hyperlink{structcimg__library_1_1CImg}{CImg$<$char$>$} with support for implanting and extracting data. This is a specific CImg subclass (each pixel being of type char) which supports data implantation and extraction in a relatively JPEG compression immune fashion. Implanted data will still require error correction coding to be fully recovered. 

\subsection{Member Function Documentation}
\hypertarget{structDataCarrierImg_ad115dc610f3f7528767d4aa45fa35b66}{
\index{DataCarrierImg@{DataCarrierImg}!format\_\-for\_\-implantation@{format\_\-for\_\-implantation}}
\index{format\_\-for\_\-implantation@{format\_\-for\_\-implantation}!DataCarrierImg@{DataCarrierImg}}
\subsubsection[{format\_\-for\_\-implantation}]{\setlength{\rightskip}{0pt plus 5cm}void format\_\-for\_\-implantation (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{structDataCarrierImg_ad115dc610f3f7528767d4aa45fa35b66}


Format the image in preparation for implantation. 

This operation will resize the image to 720x720x1 and truncate the colour channels, as only data storage in single-\/channel (greyscale) image is supported. JPEG compression requires an (imperfect) colour space transform from RGB to YCrCb which complicates using colour images for data storage. Even worse -\/ Facebook's JPEG compression process uses chrominance subsampling. However, this does mean that discarding the additional two chrominance channels only results in a 50 reduction in maximum potential data storage capacity. \hypertarget{structDataCarrierImg_a5fdd25e16c1d5b86b68acac5a24ecae4}{
\index{DataCarrierImg@{DataCarrierImg}!implant\_\-data@{implant\_\-data}}
\index{implant\_\-data@{implant\_\-data}!DataCarrierImg@{DataCarrierImg}}
\subsubsection[{implant\_\-data}]{\setlength{\rightskip}{0pt plus 5cm}void implant\_\-data (
\begin{DoxyParamCaption}
\item[{std::vector$<$ char $>$ \&}]{ data}
\end{DoxyParamCaption}
)}}
\label{structDataCarrierImg_a5fdd25e16c1d5b86b68acac5a24ecae4}


Implant a specified vector$<$char$>$ into the image. 

This operation implants a data vector into the image, using 3 bytes per 8x8 pixel block. The final two blocks are reserved for storing the length of the data vector, so it may be easily recovered. Unused blocks are padded with random data. This function may throw DataCarrierImgExtractionException, normally if the data provided is too large to store. /param data The vector$<$char$>$ that we wish to implant in the image. Must be no more than 24294 bytes (90x90 blocks, 3 bytes per block, subtract 6-\/byte length tag). \hypertarget{structDataCarrierImg_a7769dc5e2644c5c1d13cbeb7235c5304}{
\index{DataCarrierImg@{DataCarrierImg}!extract\_\-data@{extract\_\-data}}
\index{extract\_\-data@{extract\_\-data}!DataCarrierImg@{DataCarrierImg}}
\subsubsection[{extract\_\-data}]{\setlength{\rightskip}{0pt plus 5cm}void extract\_\-data (
\begin{DoxyParamCaption}
\item[{std::vector$<$ char $>$ \&}]{ data}
\end{DoxyParamCaption}
)}}
\label{structDataCarrierImg_a7769dc5e2644c5c1d13cbeb7235c5304}


Attempt to allocate and return a new vector$<$char$>$ containing the extracted data. 

This operation allocates a new vector$<$char$>$ big of a size denoted by the length tag at the end (last two 8x8 pixel blocks) of the image. Extraction of the data is then attempted. This function may well throw DataCarrierImgExtractionException since the image may be a normal Facebook image and not contain anything. 